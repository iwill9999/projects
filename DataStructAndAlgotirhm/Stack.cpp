//
// Created by 杰 on 2022/3/15.
//用栈括号匹配
//
# include <iostream>
# include<stack>

using namespace std;


// 括号匹配
bool pare(const char exp[], int low, int hi) {
    stack<char> S;
    for(int i = low; i < hi;i++){
        if (exp[i] == '('){ //遇到左括号
            S.push(exp[i]);
        } //下面两种是遇到右括号
        else if (!S.empty()) {
            S.pop(); //遇到右括号：栈不为空时，弹出左括号
        }else{//遇到有括号：栈空了，说明括号不匹配
            return false;
        }
    }
    return S.empty(); //最终栈空了说明匹配了
}

/*
栈混洗
栈中共有n个数 混洗后可能的结果是 2n! / (n+1)!n!
n = 3  6!/4!3! =  5种
1 <= i < j < k <= n 不能出现 kij的顺序 称为禁形 是判断是否为准混洗的充分必要条件
j+1 ,i , j出现也是 非栈混洗的充分必要条件
*/



/*
 * 逆波兰表达式 （0！+1）^(2*3!+4-5)
 * 手工转换： 1.用括号显示地表示优先级 {([0!]+1)^([(2*[3!])+4]-5)}
 * 2.将运算法移到对应的右括号后
 *  {([0!]+1)^([(2*[3 ]！)+4]-5)}
 *  {([0!]+1)^([(2 [3 ]！)*+4]-5)}
 *  {([0!]+1)^([(2 [3 ]！)* 4]+-5)}
 *  {([0!]+1)^([(2 [3 ]！)* 4]+ 5)-}
 *  {([0!]+1) ([(2 [3 ]！)* 4]+ 5)-}^
 *  {([0 ]!+1) ([(2 [3 ]！)* 4]+ 5)-}^
 *  {([0 ]! 1)+ ([(2 [3 ]！)* 4]+ 5)-}^
 *  3.抹去所有括号
 *  得 0 ! 1 + 2 3 ! * 4 + 5 - ^
 *  运算符的次序有可能改变，运算数的位置不会改变
 */





int main() {

    return 0;
}
